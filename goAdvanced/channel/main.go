package main

import (
	"fmt"
	"sync"
)

/**
题目 ：编写一个程序，使用通道实现两个协程之间的通信。
一个协程生成从1到10的整数，并将这些整数发送到通道中，另一个协程从通道中接收这些整数并打印出来。
*/
/*
func main() {

	//有缓冲池和无缓冲的channel的区别？
	//无缓冲channel在发送和接收时必须同步。
	//缓冲channel则允许异步发送。
	//缓冲区满前，可以随时写入，不会阻塞，直到缓冲区满后，写入需要等缓冲区有空余位置。
	//如果缓冲区没有数据，那么读取会阻塞，只要有数据为止。
	//

	//创建一个无缓冲的证书通道

	ch := make(chan int)

	//启动柜发动协程

	//func() { ... } - 这是一个匿名函数的定义
	//
	//() - 这对括号表示"调用这个函数"
	//
	//go - 关键字表示在新的 goroutine 中执行这个函数调用
	go func() {
		time.Sleep(5 * time.Second)
		for i := 1; i <= 10; i++ {
			ch <- i //将证书i发送到通道中
		}
		defer close(ch)
	}()

	//启动接受协程（在住协程中直接同步接收）

	//这个循环确实会等待发送方发送数据，因为：
	//无缓冲通道是同步的：无缓冲通道的发送和接收操作是同步进行的。
	//发送操作会阻塞，直到有接收方准备好接收；反之，接收操作也会阻塞，直到有发送方准备好发送。
	//range通道的语义：使用for range遍历通道时，循环会在每次迭代时阻塞，
	//等待从通道接收下一个值。只有当通道被关闭且没有更多数据时，循环才会退出。
	//
	for num := range ch {
		fmt.Println(num)
	}
}*/

/**
题目 ：实现一个带有缓冲的通道，生产者协程向通道中发送100个整数，消费者协程从通道中接收这些整数并打印。
考察点 ：通道的缓冲机制。
*/

/*
	func main() {
		ch := make(chan int, 100)

		go func() {
			for i := 1; i <= 100; i++ {
				ch <- i
			}
			defer close(ch)
		}()

		for v := range ch {
			fmt.Println(v)
		}
	}
*/

/**
内部工作机制
WaitGroup 的内部实现大致如下：

计数器：维护一个内部计数器，记录尚未完成的协程数量

信号量：使用操作系统提供的信号量机制实现阻塞和唤醒

原子操作：使用原子操作确保计数器的线程安全

当调用 wg.Wait() 时：

如果计数器 > 0，当前协程会被放入等待队列并阻塞

当其他协程调用 wg.Done() 使计数器减为 0 时，等待队列中的所有协程会被唤醒

实际执行流程
在生产者-消费者示例中的执行流程：

主协程调用 wg.Add(2)（计数器 = 2）

主协程启动生产者和消费者协程

主协程调用 wg.Wait() 并阻塞

生产者完成工作后调用 wg.Done()（计数器 = 1）

消费者完成工作后调用 wg.Done()（计数器 = 0）

主协程被唤醒，继续执行后续代码

程序正常退出
*/

func main() {
	// 创建一个缓冲大小为10的整数通道
	ch := make(chan int, 10)

	// 使用WaitGroup等待两个协程完成
	var wg sync.WaitGroup
	wg.Add(2) // 等待两个协程

	// 生产者协程：发送100个整数到通道
	go func() {
		defer wg.Done() // 函数结束时通知WaitGroup
		for i := 1; i <= 100; i++ {
			ch <- i // 将整数发送到缓冲通道
			fmt.Printf("生产者发送: %d\n", i)
		}
		close(ch) // 发送完成后关闭通道
		fmt.Println("生产者完成")
	}()

	// 消费者协程：从通道接收整数并打印
	go func() {
		defer wg.Done() // 函数结束时通知WaitGroup
		for num := range ch {
			fmt.Printf("消费者接收: %d\n", num)
		}
		fmt.Println("消费者完成")
	}()

	// 等待生产者和消费者协程完成
	wg.Wait()
	fmt.Println("程序结束")
}
